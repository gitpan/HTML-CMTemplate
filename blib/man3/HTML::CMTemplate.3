.rn '' }`
''' $RCSfile$$Revision$$Date$
'''
''' $Log$
'''
.de Sh
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp
.if t .sp .5v
.if n .sp
..
.de Ip
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb
.ft CW
.nf
.ne \\$1
..
.de Ve
.ft R

.fi
..
'''
'''
'''     Set up \*(-- to give an unbreakable dash;
'''     string Tr holds user defined translation string.
'''     Bell System Logo is used as a dummy character.
'''
.tr \(*W-|\(bv\*(Tr
.ie n \{\
.ds -- \(*W-
.ds PI pi
.if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\" diablo 12 pitch
.ds L" ""
.ds R" ""
'''   \*(M", \*(S", \*(N" and \*(T" are the equivalent of
'''   \*(L" and \*(R", except that they are used on ".xx" lines,
'''   such as .IP and .SH, which do another additional levels of
'''   double-quote interpretation
.ds M" """
.ds S" """
.ds N" """""
.ds T" """""
.ds L' '
.ds R' '
.ds M' '
.ds S' '
.ds N' '
.ds T' '
'br\}
.el\{\
.ds -- \(em\|
.tr \*(Tr
.ds L" ``
.ds R" ''
.ds M" ``
.ds S" ''
.ds N" ``
.ds T" ''
.ds L' `
.ds R' '
.ds M' `
.ds S' '
.ds N' `
.ds T' '
.ds PI \(*p
'br\}
.\"	If the F register is turned on, we'll generate
.\"	index entries out stderr for the following things:
.\"		TH	Title 
.\"		SH	Header
.\"		Sh	Subsection 
.\"		Ip	Item
.\"		X<>	Xref  (embedded
.\"	Of course, you have to process the output yourself
.\"	in some meaninful fashion.
.if \nF \{
.de IX
.tm Index:\\$1\t\\n%\t"\\$2"
..
.nr % 0
.rr F
.\}
.TH CMTemplate 3 "perl 5.005, patch 03" "29/Aug/2001" "User Contributed Perl Documentation"
.UC
.if n .hy 0
.if n .na
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.de CQ          \" put $1 in typewriter font
.ft CW
'if n "\c
'if t \\&\\$1\c
'if n \\&\\$1\c
'if n \&"
\\&\\$2 \\$3 \\$4 \\$5 \\$6 \\$7
'.ft R
..
.\" @(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2
.	\" AM - accent mark definitions
.bd B 3
.	\" fudge factors for nroff and troff
.if n \{\
.	ds #H 0
.	ds #V .8m
.	ds #F .3m
.	ds #[ \f1
.	ds #] \fP
.\}
.if t \{\
.	ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.	ds #V .6m
.	ds #F 0
.	ds #[ \&
.	ds #] \&
.\}
.	\" simple accents for nroff and troff
.if n \{\
.	ds ' \&
.	ds ` \&
.	ds ^ \&
.	ds , \&
.	ds ~ ~
.	ds ? ?
.	ds ! !
.	ds /
.	ds q
.\}
.if t \{\
.	ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.	ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.	ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.	ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.	ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.	ds ? \s-2c\h'-\w'c'u*7/10'\u\h'\*(#H'\zi\d\s+2\h'\w'c'u*8/10'
.	ds ! \s-2\(or\s+2\h'-\w'\(or'u'\v'-.8m'.\v'.8m'
.	ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.	ds q o\h'-\w'o'u*8/10'\s-4\v'.4m'\z\(*i\v'-.4m'\s+4\h'\w'o'u*8/10'
.\}
.	\" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds v \\k:\h'-(\\n(.wu*9/10-\*(#H)'\v'-\*(#V'\*(#[\s-4v\s0\v'\*(#V'\h'|\\n:u'\*(#]
.ds _ \\k:\h'-(\\n(.wu*9/10-\*(#H+(\*(#F*2/3))'\v'-.4m'\z\(hy\v'.4m'\h'|\\n:u'
.ds . \\k:\h'-(\\n(.wu*8/10)'\v'\*(#V*4/10'\z.\v'-\*(#V*4/10'\h'|\\n:u'
.ds 3 \*(#[\v'.2m'\s-2\&3\s0\v'-.2m'\*(#]
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.ds oe o\h'-(\w'o'u*4/10)'e
.ds Oe O\h'-(\w'O'u*4/10)'E
.	\" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.	\" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.	ds : e
.	ds 8 ss
.	ds v \h'-1'\o'\(aa\(ga'
.	ds _ \h'-1'^
.	ds . \h'-1'.
.	ds 3 3
.	ds o a
.	ds d- d\h'-1'\(ga
.	ds D- D\h'-1'\(hy
.	ds th \o'bp'
.	ds Th \o'LP'
.	ds ae ae
.	ds Ae AE
.	ds oe oe
.	ds Oe OE
.\}
.rm #[ #] #H #V #F C
.SH "NAME"
HTML::CMTemplate.pm \- Generate text-based content from templates.
.SH "SYNOPSIS"
.PP
.Vb 1
\&  use HTML::CMTemplate;
.Ve
.Vb 1
\&  $t = new HTML::CMTemplate( path => [ '/path1', '/longer/path2' ] );
.Ve
.Vb 6
\&  $t->import_template(
\&    filename => 'file.html.ctpl', # in the paths above
\&    packagename => 'theTemplate',
\&    importrefs => { myvar => 'hello' },
\&    importclean => { myclean => 'clean!' },
\&    );
.Ve
.Vb 1
\&  theTemplate::cleanup_namespace();
.Ve
.Vb 2
\&  print "Content-type: text/html\en\en";
\&  print theTemplate::output();
.Ve
.Vb 2
\&  # Template syntax is described below -- see that section to get the real
\&  # details on how to use this sucker.
.Ve
.SH "DESCRIPTION"
HTML::CMTemplate 0.2
.PP
A class for generating text-based content from a simple template language.
It was inspired by the (as far as I'm concerned, incomplete) HTML::Template
module, and was designed to make template output extremely fast by
converting a text/html template into a dynamic perl module and then running
code from that module.  Since the parsing happens only once and the template
is converted into Perl code, the output of the template is very fast.
.PP
It was designed to work with mod_perl and FastCGI and has been the basis
for all of the dynamic content on the Orangatango site
(http://www.orangatango.com).
.PP
First release (version 0.1) was February 15, 2001 and was \fIvery\fR quiet
because it was a proprietary version.
.PP
As of version 0.2, it is released under the Artistic License.  It's a much
more feature-rich version as well as being Open Source!
For a copy of the Artistic License, see the files that came with your
Perl distribution.
.PP
The code was developed during my time at Orangatango.  It has been released
as open source with the blessing of the controlling entities there.
.SH "AUTHOR"
Chris Monson, chris@bouncingchairs.net
.Sh "\s-1TEMPLATE\s0 \s-1SYNTAX\s0"
The template syntax that this parser recognizes has a few tags that look
a little like php or xml syntax, except that they are different.  The tags
all start with <?= and end with ?>.  If the next character after ?> is a
newline, it is also eaten up with the tag, just like in \s-1PHP\s0.  This gives you
very fine grained control over the actual template output, and is especially
important when using loops to generate output.
.PP
Note that if you want to actually output those symbols in your code, or you
want to access them inside of a tag, I have created two global variables that
contain those strings:  \f(CW$START_SYM\fR and \f(CW$END_SYM\fR.  So, to print something
like <?=hello?> inside of your template, you would do this:
.PP
.Vb 1
\&    <?=echo $START_SYM?>hello<?=echo $END_SYM?>
.Ve
Or, if you use the shortcut (all explained below), you would do this:
.PP
.Vb 1
\&    <?=$START_SYM?>hello<?=$END_SYM?>
.Ve
An explanation follows of the different constructs that the engine uses.
.PP
\fIcomment\fR
.PP
The \fIcomment\fR construct is just a single tag.  The whole tag is eaten
by the template engine and is never seen again.  This simply serves
as a comment in the template itself.
.PP
.Vb 1
\&    <?=comment  This is a comment ?>
.Ve
\fIecho\fR
.PP
The \fIecho\fR construct supports two tags: 
.PP
.Vb 2
\&    <?=echo --expression-- ?>
\&    <?=--expression--?>
.Ve
The second tag is a handy shortcut for the first, and works like its
corresponding \s-1PHP\s0 tag.  Both are replaced with the value of the evaluated
expression.  This is by far the most used construct, since usually the
result of an expression simply needs to be inserted into the appropriate place.
.PP
Example:
.PP
.Vb 3
\&    ...
\&    <title><?=$document_title?></title>
\&    ...
.Ve
This could also be written as
.PP
.Vb 3
\&    ...
\&    <title><?=echo $document_title?></title>
\&    ...
.Ve
Both will replace the tag with the contents of the \f(CW$document_title\fR variable.
.PP
But, where does \f(CW$document_title\fR come from?  Going back to the synopsis, if
you do something like this in your perl script:
.PP
.Vb 4
\&    $t->import_template(
\&        filename => 'thetemplate.html.ctpl',
\&        packagename => 'theTemplate',
\&        );
.Ve
Then you can set the variable in the newly-created package (There is no
need to do a \*(L'use\*(R' or a \*(L'require\*(R' or anything.  The package is created
when you call the import_template function and is thereafter available).
.PP
You create the variable thus:
.PP
.Vb 1
\&    $theTemplate::document_title = "My Document Title";
.Ve
Then to output the template, you would do something like this:
.PP
.Vb 3
\&    print "Content-type: text/html\en";
\&    print "\en";
\&    print theTemplate::output();
.Ve
Note that the import_template function does not import the template again
if it detects that the template or any of its includes (see below) have not
changed.  This is an optimization to reduce needless parsing, since once
the template is in memory, you can use it over and over again with new
variables by just changing the variable values in the package namespace.
.PP
.Vb 2
\&    NOTE: This behavior can be changed by setting the $t->{checkmode} variable
\&    to $HTML::CMTemplate::CHECK_NONE.
.Ve
So, if I wanted to output the template again with a new title, I could simply
do the following:
.PP
.Vb 4
\&    $theTemplate::document_title = "My NEW Document Title";
\&    print "Content-type: text/html\en";
\&    print "\en";
\&    print theTemplate::output();
.Ve
Note that an import_template was not necessary again, since the template
was converted into code and all we wanted to do was change a variable.
.PP
Again, if you do call import_template on the same object ($t in the examples)
more than once, it will only actually parse the template once, unless you
change it on disk in between import_template calls.
.PP
\fIif\fR
.PP
The \fIif\fR construct supports several tags, some of which are reused in the
\fIfor\fR construct:
.PP
.Vb 4
\&    <?=if --expression-- :?>
\&    <?=elif --expression-- :?>
\&    <?=else :?>
\&    <?=endif?>
.Ve
These tags do basically what you would expect them to do.  Note that none
of the expressions require surrounding parentheses.  They do require terminating
colons, however.  Whitespace is not important except between the tag name ('if')
and the expression.
.PP
So, as an example of how you might do things:
.PP
.Vb 5
\&    <?=if $testvar:?>
\&    TESTVAR set!
\&    <?=else:?>
\&    TESTVAR NOT set!
\&    <?=endif?>
.Ve
The \fIelif\fR tag works just like an elsif in Perl.
.PP
\fIfor\fR
.PP
The \fIfor\fR contruct supports several tags, as well.  It works like Python's
\fIfor\fR loop construct and has a similar syntax.  In fact, all of these tags
borrowed some of their syntax from Python.
.PP
The supported tags are as follows:
.PP
.Vb 5
\&    <?=for --varname-- in --list expression-- :?>
\&    <?=break?>
\&    <?=continue?>
\&    <?=else:?>
\&    <?=endfor?>
.Ve
These tags, with the exception of the \*(L'else\*(R' tag (since it doesn't exist) do
what you would expect them to do in Perl.  The \*(L'for\*(R' and \*(L'else\*(R' tags deserve
a little extra explanation since they are not real Perl syntax.
.PP
The --varname-- is the name of a variable that will be assigned the value
of the current list item.  The --list expression-- is an expression that
evaluates to a real Perl array (\s-1NOT\s0 an arrayref).  Each item in the array will
be assigned to --varname-- in order.  Here is an example.  Assume for the sake
of this example that an array of integers 1 thru 10 named \*(L'@list\*(R' exists in
the package's namespace:
.PP
.Vb 13
\&    <table>
\&    <?=comment
\&        Note that you can use either 'i' or '$i' here.
\&        They are equivalent in the for tag.  The echo tag
\&        MUST use '$i' because it is outputting a perl expression
\&        and is not specially parsed at all.
\&    ?>
\&    <?=for i in @list:?>
\&    <tr><td>Number <?=echo $i?></td></tr>
\&    <?=else:?>
\&    <tr><td>Completed normally</td></tr>
\&    <?=endfor?>
\&    </table>
.Ve
Note that you don't have to output \s-1HTML\s0.  Any kind of text can be output,
but \s-1HTML\s0 is what this was originally designed for.
.PP
This will loop on the elements of \f(CW@list\fR, which contains the numbers 1 thru 10
in order.  It will output the following code:
.PP
.Vb 13
\&    <table>
\&    <tr><td>Number 1</td></tr>
\&    <tr><td>Number 2</td></tr>
\&    <tr><td>Number 3</td></tr>
\&    <tr><td>Number 4</td></tr>
\&    <tr><td>Number 5</td></tr>
\&    <tr><td>Number 6</td></tr>
\&    <tr><td>Number 7</td></tr>
\&    <tr><td>Number 8</td></tr>
\&    <tr><td>Number 9</td></tr>
\&    <tr><td>Number 10</td></tr>
\&    <tr><td>Completed Normally</td></tr>
\&    </table>
.Ve
Note the extra table element at the end that says \*(L"Completed Normally\*(R".  This
is inserted because of the \fIelse\fR tag after the for block.  Like in Python, the
code in the else tag is executed if the \fIfor\fR loop is not terminated with a
\fIbreak\fR tag.  If the for loop is terminated with a \fIbreak\fR tag, then the
\fIelse\fR block will not execute.
.PP
The \fIbreak\fR and \fIcontinue\fR tags work as you would expect the corresponding
\&'last\*(R' and \*(L'next\*(R' keywords to work in Perl.
.PP
There are several functions to ease your way in \fIfor\fR loops.  They are listed
here:
.PP
.Vb 5
\&    for_list( $depth )
\&    for_index( $depth )
\&    for_count( $depth )
\&    for_is_first( $depth )
\&    for_is_last( $depth )
.Ve
The for_list function gives you access to an arrayref of the list over which
the loop (or one of its containing loops, if \f(CW$depth\fR > 0) is iterating.
.PP
The for_index function gives you a number from 0 to len-1, depending on where
you are in the actual loop.
.PP
The for_count function gives you the number of elements over which you are
iterating.
.PP
The for_is_first function tells you whether this is the first element, and the
for_is_last function tells you whether this is the last one.
.PP
Note that all of these functions give you the ability to specify a depth.  If
you have nested \*(L'for\*(R' tags and you want to access the index, count, or list of
a containing \*(L'for\*(R' loop, you can do that by specifying a depth parameter in the
function.  No depth parameter or a value of 0 indicates that you want the
values for the current loop.  A value of 1 would indicate that you want the
values for the immediately enclosing loop, etc.
.PP
Example:
    Suppose \f(CW@xlist\fR = (1, 2, 3) and \f(CW@ylist\fR = (2, 4, 6):
.PP
.Vb 5
\&    <?=for x in @xlist:?>
\&    <?=for y in @ylist:?>
\&        <?=$x?>,<?=$y?> :: <?=echo for_index(1)?>,<?=echo for_index()?>
\&    <?=endfor?>
\&    <?=endfor?>
.Ve
.Vb 10
\&    prints:
\&        1,2 :: 0,0
\&        1,4 :: 0,1
\&        1,6 :: 0,2
\&        2,2 :: 1,0
\&        2,4 :: 1,1
\&        2,6 :: 1,2
\&        3,2 :: 2,0
\&        3,4 :: 2,1
\&        3,6 :: 2,2
.Ve
We can also tell if the current element is the first or last.  Rather than
give an example for that simple case, it is left as an exercise for the reader.
A hint, however, is that you should use for_is_first and for_is_last (functions
that can also take a depth argument).
.PP
As a side note, here, I should mention that tabbing loop and conditional
constructs does not work the way that you think it might inside of a template.
Since the only thing that is eaten up in a template is the tag itself, not
the preceding whitespace, usually you want the loop constructs and other
kinds of block constructs to be located all the way to the left side.  This
will ensure that your spacing is really what you think it should be.
.PP
\fIdef\fR
.PP
The \fIdef\fR construct is a very powerful little tool.  It corresponds loosely
to Python's def in that it defines a sort of \*(L"template function\*(R" which can
be \*(L"called\*(R".  An example will best illustrate this.
.PP
By the way, the tags that are used by this construct are the following:
.PP
.Vb 3
\&    <?=def --functionname--( --arglist-- ):?>
\&    <?=enddef?>
\&    <?=call --functionname--( --arglist-- )?>
.Ve
Here is that promised example:
.PP
.Vb 2
\&    <?=def tempfunc( a, b, c ): ?>
\&        a = <?=echo $a?>
.Ve
.Vb 1
\&        b = <?=echo $b?>
.Ve
.Vb 1
\&        c = <?=echo $c?>
.Ve
.Vb 3
\&    <?=enddef?>
\&    <?=call tempfunc( 1, 2, 3 )?>
\&    <?=call tempfunc( 4, 5, 6 )?>
.Ve
This will print the following:
.PP
.Vb 6
\&        a = 1
\&        b = 2
\&        c = 3
\&        a = 4
\&        b = 5
\&        c = 6
.Ve
I think it's pretty self-explanatory.  Note that you can embed any number of
recursive constructs inside of not only the \fIdef\fR tags, but also \fIif\fR and
\fIfor\fR tags, along with their corresponding inner tags.
.PP
\fB\s-1NOTE\s0\fR: No matter where a template subroutine is defined (def tag), the
subroutine ends up in the global package scope.  All defs are global.  Period.
This is by design and actually required a large amount of work to do, so
don't you go thinking that it's because I'm lazy ;\-).
.PP
The reasoning behind this is to keep namespace clashes from happening when
one template includes another.  If the functions are treated differently
from other constructs (since Perl treats them differently anyway), namespace
collisions can be detected.  Additionally, if one module includes two others,
each of which include the same module, the functions from that last module
are the same.  Functions in the global scope keep these from wrongly stomping
on each other.
.PP
\fIexec\fR
.PP
This one is somewhat dangerous, and should be used with great care.
It allows you to execute arbitrary Perl code inside of the tag.
.PP
.Vb 6
\&    <?=exec
\&        $a = 1;
\&        $b = 2;
\&        $c = $a + $b;
\&        print STDERR "Debug this output function!";
\&    ?>
.Ve
This will set the variables just as you think it will, but it will
do it in a somewhat strange scope and you might get a bit confused.  Look at
the code that is generated (by calling \f(CW$t\fR\->\fIoutput_perl()\fR) to see
exactly what goes on.
.PP
Note that the package that is created from this template explicitly declares
no strict \*(L'vars\*(R', so the exec tag above will actually create global variables
in the package's namespace.  You can also create \*(L'my\*(R' variables, which is
really useful inside of loops.
.PP
The best uses I have found for this tag are as follows:
.PP
.Vb 3
\&    * Creating temporary variables or aliases to complicated variables.
\&    * Creating 'my' variables inside of loops to improve efficiency.
\&    * Outputing debug code using print STDERR "stuff" constructs.
.Ve
Beyond this, I have serious misgivings about the tag.  Just be careful.  Your
code will be inserted as is into the template code.  Don't forget semicolons,
etc.
.PP
\fIinc\fR
.PP
This includes another template where the tag is located.  It tests for
infinite recursion and does not allow it.  Also, note that this does \s-1NOT\s0
take an arbitrary perl expression as a filename.  It only takes strings.
The filename can be quoted with either single or double quotes.
.PP
This parses the file just like any other template, looking for tags.  If you
don't want the file parsed, use \*(L'rawinc\*(R' instead.
.PP
\fIrawinc\fR
.PP
Just like \*(L'inc\*(R', but it doesn't parse the file.  Simple.
.Sh "\s-1IMPORTED\s0 \s-1UTILITIES\s0"
You have access to several functions.  Most of the time you will only use
a couple of them, but there are several there for the sake of completeness and
sanity.
.PP
\fIoutput()\fR
.PP
This is used to output the code given the current namespace.  Simple.  It
returns a string.
.PP
\fIimport_hashref()\fR
.PP
This is extremely useful for importing the variables from another namespace.
I routinely do the following:
.PP
.Vb 3
\&    use CMCONFIG;
\&     ...
\&    theTemplate::import_hashref( \e%CMCONFIG:: );
.Ve
You can also set up your own hashref of variables.  This is useful for getting
form elements from \s-1CGI\s0 stuff:
.PP
.Vb 2
\&    theTemplate::import_hashref( \e%FORM );
\&    theTemplate::import_hashref( { myvar => 'value' } );
.Ve
That would set all of the \s-1FORM\s0 data to be global variables (\s-1PHP\s0 style) in
the package, and it would additionally set \f(CW$myvar\fR to be \*(L'value\*(R'.
.PP
Note that you can pass an extra parameter (1 or 0) to indicate that you want
the variables imported into the \*(L'clean\*(R' namespace.  More on this later.
.PP
\fIcleanup_namespace()\fR
.PP
This deletes all variables from the package's namespace except those that
are designated \*(L'clean\*(R'.  Clean variables are the functions that are
automatically defined and the globals that are used by the package before
anything is done to it.  They are also variables that have been imported and
marked \*(L'clean\*(R'.
.PP
This function is really important, especially in cases where the template is
being generated with fastcgi or mod_perl, since the modules will have their
variables maintained across page loads.  That means that the previous user's
password (for example) could be available in the page.  Bad, bad things happen
at that point.
.PP
So, it is useful to call cleanup_namespace before using the template.  It is
also useful to import things like system-wide configuration parameters into
the clean namespace, since these aren't sensitive to change and can take a
little extra time to import.
.PP
\fIadd_clean_names()\fR
.PP
If you import a ton of variables and want to mark some of them clean, use this
function.
.Sh "\s-1FUNCTIONS\s0"
\fInew( %args )\fR
.PP
Creates an instance of the \s-1HTML::\s0CMTemplate class.  Potentially takes several
parameters.
.PP
.Vb 2
\&    parent: Template which immediately "owns" this template.  Should only be
\&        used internally.
.Ve
.Vb 1
\&    root: Template at the top of the tree.  Also internal use only.
.Ve
.Vb 1
\&    NOTE: NEVER use parent or root.  NEVER do it!  Don't!  Jerk.
.Ve
.Vb 5
\&    path: An array ref of file paths.  These paths will be searched when
\&        non-absolute template filenames are given.  Note that if a string
\&        is passed in instead of an arrayref, it will be treated as a single
\&        file path, not as a ':' or ';' delimited list of paths.  If it has
\&        illegal characters, the search will simply not work.
.Ve
.Vb 2
\&        NOTE that you do NOT need to include '.' explicitly.  It will always
\&        be checked FIRST before the listed directories.
.Ve
.Vb 1
\&    nocwd: 1 or 0.  Tells the path parser to leave cwd out of it.
.Ve
\fIopen_file( $filename, $path )\fR
.PP
Takes one or two parameters.
This function looks for the indicated file and parses it
into an internal structure.  Once this is done, it is capable of outputting
perl code or importing an indicated package with said code in the output
function.  The file is looked for in the path specified during template
creation.
.PP
Note that even if a relative filename is passed in (relative to any part
of the path, including \*(L'.') the filename will be converted to an absolute path
internally.  This is the way that infinite recursion is detected and
templates are never parsed more than once.
\fIimport_template( %args )\fR
.PP
Open the file, parse it, and import the indicated variables.
This will leave the client with an imported package that can be used
to generate output.  This does not actually call the output function!  That
would be too confining.
.PP
The reason that this function exists is that it is by far the most used
operation.  The most frequent need when dealing with templates is to open
them up and import them into a namespace, including some predefined variables
that are well known.  This allows one function call to replace several.
.PP
The arguments to this function are supposed to be named and are as follows:
.Ip "\(bu" 4
\&'filename\*(R' => name of file
.Ip "\(bu" 4
\&'packagename\*(R' => name of package into which the code is imported
.Ip "\(bu" 4
\&'path\*(R' => arrayref of directories to add to the main path just for this import
.Ip "\(bu" 4
\&'warn\*(R' => if defined, turns warnings on in the generated module
.Ip "\(bu" 4
\&'importrefs\*(R' => optional arrayref of hashrefs to import into the namespace
.Ip "\(bu" 4
\&'importclean\*(R' => optional arrayref of hashrefs to import into the clean space
\fIimport_package( $packagename, $warn )\fR
.PP
Once a file has been opened and parsed, the code to generate the template can
be imported into a package of the specified name.  In order to really make
the tempalate useful, the generated code should be imported into a package
so that it can have its own namespace.  Mind you, the template can actually
be imported into the current package, but this is not suggested or encouraged
since it is generating code that might do nasty things to your global variables.
.PP
The \f(CW$warn\fR parameter turns warnings on or off in the generated module.
Leave it out or set to zero for default behavior (off).
\fIoutput_perl_code( %args )\fR
.PP
Accepts a depth argument.  This just outputs the code without any surrounding
context and no helper functions, including the functions defined in the
template itself.  Just the code.  Just the code.  Remember that: just the code.
If you can't figure out what \*(L"just the code\*(R" means, call this function and
the output_perl function and do a diff.  It will become immediately obvious to
you.  You may want to consider turning off detection of whitespace in that
diff....
\fIoutput_perl( %args )\fR
.PP
This function outputs perl code that will generate the template output.  The
code that is generated turns off strict \*(L'vars\*(R'.
.PP
The allowed parameters are:
.PP
.Vb 3
\&    packagename (required)
\&    depth
\&    warn
.Ve
If the depth is specified, then the code will indent itself that many times at
the top level.  The indentation amount is four spaces by default and cannot
currently be changed.
.PP
If warn is specified, the warn variable ($^W) in the generated module
is set to that value.  Default is 0 (off).
.PP
This always requires a packagename.  The packagename is used to generate
the surrounding context for the code output.  If you don't want the package,
the surrounding context, and the function definitions, you are really looking
for output_perl_code, which just outputs the code definition for this template
without any surrounding context.
.SH "FORMAL GRAMMAR DEFINITION"
.PP
.Vb 3
\&    template :==
\&        text block template
\&        | NULL
.Ve
.Vb 3
\&    text :==
\&        ANY_CHAR_LITERAL
\&        | NULL
.Ve
.Vb 13
\&    block :==
\&        if_block
\&        | for_block
\&        | def_block
\&        | comment_tag
\&        | echo_tag
\&        | call_tag
\&        | inc_tag
\&        | rawinc_tag
\&        | exec_tag
\&        | break_tag
\&        | continue_tag
\&        | NULL
.Ve
.Vb 2
\&    if_block :==
\&        if_tag template [ elif_tag template ]* [ else_tag template ]? endif_tag
.Ve
.Vb 2
\&    for_block :==
\&        for_tag template [ else_tag template ]? endfor_tag
.Ve
.Vb 2
\&    def_block :==
\&        def_tag template enddef_tag
.Ve
.Vb 2
\&    comment_tag :==
\&        START_SYMBOL OP_COMMENT WS TEXT WS? end_symbol
.Ve
.Vb 2
\&    echo_tag :==
\&        START_SYMBOL OP_ECHO WS simple_expr WS? end_symbol
.Ve
.Vb 2
\&    if_tag :==
\&        START_SYMBOL OP_IF WS simple_expr WS? end_symbol_block
.Ve
.Vb 2
\&    elif_tag :==
\&        START_SYMBOL OP_ELIF WS simple_expr WS? end_symbol_block
.Ve
.Vb 2
\&    else_tag :==
\&        START_SYMBOL OP_ELSE WS? end_symbol_block
.Ve
.Vb 2
\&    endif_tag :==
\&        START_SYMBOL OP_ENDIF WS? end_symbol
.Ve
.Vb 2
\&    for_tag :==
\&        START_SYMBOL OP_FOR WS var_name WS OP_IN WS simple_expr WS? end_symbol_block
.Ve
.Vb 2
\&    endfor_tag :==
\&        START_SYMBOL OP_ENDFOR WS? end_symbol
.Ve
.Vb 2
\&    break_tag :==
\&        START_SYMBOL OP_BREAK WS? end_symbol
.Ve
.Vb 2
\&    continue_tag :==
\&        START_SYMBOL OP_CONTINUE WS? end_symbol
.Ve
.Vb 2
\&    def_tag :==
\&        START_SYMBOL OP_DEF WS def_name def_param_expression WS? end_symbol_block
.Ve
.Vb 2
\&    enddef_tag :==
\&        START_SYMBOL OP_ENDDEF WS? end_symbol
.Ve
.Vb 2
\&    call_tag :==
\&        START_SYMBOL OP_CALL WS def_name call_param_expression WS? end_symbol
.Ve
.Vb 2
\&    inc_tag :==
\&        START_SYMBOL OP_INC WS QUOTE? FILENAME QUOTE? WS? end_symbol
.Ve
.Vb 2
\&    rawinc_tag :==
\&        START_SYMBOL OP_INC WS QUOTE? FILENAME QUOTE? WS? end_symbol
.Ve
.Vb 2
\&    exec_tag :==
\&        START_SYMBOL OP_EXEC WS expression WS? end_symbol
.Ve
.Vb 2
\&    var_name :==
\&        OP_DOLLAR? CHAR_NAME_LITERAL
.Ve
.Vb 2
\&    def_name :==
\&        CHAR_NAME_LITERAL
.Ve
.Vb 2
\&    def_param_expression :==
\&        OP_OPEN_PAREN WS? def_param_list OP_CLOSE_PAREN
.Ve
.Vb 2
\&    def_param_list :==
\&        CHAR_NAME_LITERAL WS? [ OP_LIST_SEP WS? CHAR_NAME_LITERAL WS? ]*
.Ve
.Vb 2
\&    call_param_expression :==
\&        OP_OPEN_PAREN WS? call_param_list OP_CLOSE_PAREN
.Ve
.Vb 2
\&    call_param_list :==
\&        simple_expr WS? [ OP_LIST_SEP WS? simple_expr WS? ]*
.Ve
.Vb 2
\&    simple_expr :==
\&        SINGLE_STATEMENT_EXPR
.Ve
.Vb 2
\&    expression :==
\&        MULTI_STATEMENT_EXPR
.Ve
.Vb 2
\&    end_symbol_block :==
\&        OP_BLOCK_TERMINAL WS? end_symbol
.Ve
.Vb 2
\&    end_symbol :==
\&        END_SYM_TEXT END_SYM_WS?
.Ve
.Vb 4
\&    WS :== \es+
\&    END_SYM_WS :== \e012\e015|\e012|\e015
\&    CHAR_NAME_LITERAL :== [a-zA-Z_][a-zA-z0-9_]*
\&    QUOTE :== ["']
.Ve
.Vb 2
\&    START_SYMBOL :== '<?='
\&    END_SYM_TEXT :== '?>'
.Ve
.Vb 2
\&    OP_BLOCK_TERMINAL :== ':'
\&    OP_LIST_SEP :== ','
.Ve
.Vb 19
\&    OP_DOLLAR :== '$'
\&    OP_OPEN_PAREN :== '('
\&    OP_CLOSE_PAREN :== ')'
\&    OP_COMMENT :== 'comment'
\&    OP_ECHO :== 'echo'
\&    OP_IF :== 'if'
\&    OP_ELIF :== 'elif'
\&    OP_ELSE :== 'else'
\&    OP_ENDIF :== 'endif'
\&    OP_FOR :== 'for'
\&    OP_IN :== 'in'
\&    OP_ENDFOR :== 'endfor'
\&    OP_BREAK :== 'break'
\&    OP_CONTINUE :== 'continue'
\&    OP_DEF :== 'def'
\&    OP_ENDDEF :== 'enddef'
\&    OP_CALL :== 'call'
\&    OP_INC :== 'inc'
\&    OP_EXEC :== 'exec'
.Ve
.Vb 5
\&    SINGLE_STATEMENT_EXPR :==
\&        Any valid perl expression that is a single statement
\&        and evaluates to a single return value.  For example, the internals
\&        of an 'if' statement should evaluate to something akin to a boolean
\&        and would have the same rules as a normal 'if' statement.
.Ve
.Vb 3
\&    MULTI_STATEMENT_EXPR :==
\&        Any valid perl expression that may or may not be multiple expressions.
\&        This basically leaves the door wide open for a generic eval.
.Ve
.Vb 5
\&    FILENAME :==
\&        This is NOT a perl expression, but an actual filename.  The whitespace
\&        on either end is stripped out.  No quoting is currently allowed, so
\&        take care to not use filenames with spaces for now.
\&        Example: <?=inc file.ctpl ?>
.Ve
.Vb 2
\&    TEXT :==
\&        This is just text.  No parsing is done.  Just text.
.Ve

.rn }` ''
.IX Title "CMTemplate 3"
.IX Name "HTML::CMTemplate.pm - Generate text-based content from templates."

.IX Header "NAME"

.IX Header "SYNOPSIS"

.IX Header "DESCRIPTION"

.IX Header "AUTHOR"

.IX Subsection "\s-1TEMPLATE\s0 \s-1SYNTAX\s0"

.IX Subsection "\s-1IMPORTED\s0 \s-1UTILITIES\s0"

.IX Subsection "\s-1FUNCTIONS\s0"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Item "\(bu"

.IX Header "FORMAL GRAMMAR DEFINITION"

